function [methodinfo,structs,enuminfo,ThunkLibName]=libusb0_64_proto
% Prototype file for library "libusb0" on 64 Bit Windows
%
% Syntax
%   [methodinfo,structs,enuminfo]=libusb0_64_proto
%
% Description
%   This function was generated by loadlibrary.m
%
%   It is based on the libusb0 header-file lusb0_usb.h
%   This file was changed by hand, due to some Pointer errors
%   (thanks to Paul Hollensen for providing his Version of this file)
%
% Signature
%   Author: Martin Staas (see AUTHORS)
%   Date: 2011/09/12
%   Copyright: 2007-2011, RWTH Aachen University
;
%
% ***********************************************************************************************
% *  This file is part of the RWTH - Mindstorms NXT Toolbox.                                    *
% *                                                                                             *
% *  The RWTH - Mindstorms NXT Toolbox is free software: you can redistribute it and/or modify  *
% *  it under the terms of the GNU General Public License as published by the Free Software     *
% *  Foundation, either version 3 of the License, or (at your option) any later version.        *
% *                                                                                             *
% *  The RWTH - Mindstorms NXT Toolbox is distributed in the hope that it will be useful,       *
% *  but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  *
% *  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
% *                                                                                             *
% *  You should have received a copy of the GNU General Public License along with the           *
% *  RWTH - Mindstorms NXT Toolbox. If not, see <http://www.gnu.org/licenses/>.                 *
% ***********************************************************************************************


%This function was generated by loadlibrary.m parser version 1.1.6.33 on Fri Jun 17 12:04:53 2011
%perl options:'usb.i -outfile=libusb0_64_proto.m -thunkfile=libusb0_thunk_pcwin64.c'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'libusb0_thunk_pcwin64');
% usb_dev_handle * usb_open ( struct usb_device * dev ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrThunk';fcns.name{fcnNum}='usb_open'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='usb_dev_handlePtr'; fcns.RHS{fcnNum}={'usb_devicePtr'};fcnNum=fcnNum+1;
% int usb_close ( usb_dev_handle * dev ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='usb_close'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr'};fcnNum=fcnNum+1;
% int usb_get_string ( usb_dev_handle * dev , int index , int langid , char * buf , size_t buflen ); 
fcns.thunkname{fcnNum}='int32voidPtrint32int32cstringuint64Thunk';fcns.name{fcnNum}='usb_get_string'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32', 'int32', 'cstring', 'uint64'};fcnNum=fcnNum+1;
% int usb_get_string_simple ( usb_dev_handle * dev , int index , char * buf , size_t buflen ); 
fcns.thunkname{fcnNum}='int32voidPtrint32cstringuint64Thunk';fcns.name{fcnNum}='usb_get_string_simple'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32', 'cstring', 'uint64'};fcnNum=fcnNum+1;
% int usb_get_descriptor_by_endpoint ( usb_dev_handle * udev , int ep , unsigned char type , unsigned char index , void * buf , int size ); 
fcns.thunkname{fcnNum}='int32voidPtrint32uint8uint8voidPtrint32Thunk';fcns.name{fcnNum}='usb_get_descriptor_by_endpoint'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32', 'uint8', 'uint8', 'voidPtr', 'int32'};fcnNum=fcnNum+1;
% int usb_get_descriptor ( usb_dev_handle * udev , unsigned char type , unsigned char index , void * buf , int size ); 
fcns.thunkname{fcnNum}='int32voidPtruint8uint8voidPtrint32Thunk';fcns.name{fcnNum}='usb_get_descriptor'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'uint8', 'uint8', 'voidPtr', 'int32'};fcnNum=fcnNum+1;
% int usb_bulk_write ( usb_dev_handle * dev , int ep , char * bytes , int size , int timeout ); 
fcns.thunkname{fcnNum}='int32voidPtrint32cstringint32int32Thunk';fcns.name{fcnNum}='usb_bulk_write'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32', 'voidPtr', 'int32', 'int32'};fcnNum=fcnNum+1;
% int usb_bulk_read ( usb_dev_handle * dev , int ep , char * bytes , int size , int timeout ); 
fcns.thunkname{fcnNum}='int32voidPtrint32cstringint32int32Thunk';fcns.name{fcnNum}='usb_bulk_read'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32', 'voidPtr', 'int32', 'int32'};fcnNum=fcnNum+1;
% int usb_interrupt_write ( usb_dev_handle * dev , int ep , char * bytes , int size , int timeout ); 
fcns.thunkname{fcnNum}='int32voidPtrint32cstringint32int32Thunk';fcns.name{fcnNum}='usb_interrupt_write'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32', 'cstring', 'int32', 'int32'};fcnNum=fcnNum+1;
% int usb_interrupt_read ( usb_dev_handle * dev , int ep , char * bytes , int size , int timeout ); 
fcns.thunkname{fcnNum}='int32voidPtrint32cstringint32int32Thunk';fcns.name{fcnNum}='usb_interrupt_read'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32', 'cstring', 'int32', 'int32'};fcnNum=fcnNum+1;
% int usb_control_msg ( usb_dev_handle * dev , int requesttype , int request , int value , int index , char * bytes , int size , int timeout ); 
fcns.thunkname{fcnNum}='int32voidPtrint32int32int32int32cstringint32int32Thunk';fcns.name{fcnNum}='usb_control_msg'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32', 'int32', 'int32', 'int32', 'cstring', 'int32', 'int32'};fcnNum=fcnNum+1;
% int usb_set_configuration ( usb_dev_handle * dev , int configuration ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='usb_set_configuration'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32'};fcnNum=fcnNum+1;
% int usb_claim_interface ( usb_dev_handle * dev , int interface ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='usb_claim_interface'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32'};fcnNum=fcnNum+1;
% int usb_release_interface ( usb_dev_handle * dev , int interface ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='usb_release_interface'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32'};fcnNum=fcnNum+1;
% int usb_set_altinterface ( usb_dev_handle * dev , int alternate ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='usb_set_altinterface'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'int32'};fcnNum=fcnNum+1;
% int usb_resetep ( usb_dev_handle * dev , unsigned int ep ); 
fcns.thunkname{fcnNum}='int32voidPtruint32Thunk';fcns.name{fcnNum}='usb_resetep'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'uint32'};fcnNum=fcnNum+1;
% int usb_clear_halt ( usb_dev_handle * dev , unsigned int ep ); 
fcns.thunkname{fcnNum}='int32voidPtruint32Thunk';fcns.name{fcnNum}='usb_clear_halt'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'uint32'};fcnNum=fcnNum+1;
% int usb_reset ( usb_dev_handle * dev ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='usb_reset'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr'};fcnNum=fcnNum+1;
% char * usb_strerror ( void ); 
fcns.thunkname{fcnNum}='cstringvoidThunk';fcns.name{fcnNum}='usb_strerror'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='cstring'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% void usb_init ( void ); 
fcns.thunkname{fcnNum}='voidvoidThunk';fcns.name{fcnNum}='usb_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% void usb_set_debug ( int level ); 
fcns.thunkname{fcnNum}='voidint32Thunk';fcns.name{fcnNum}='usb_set_debug'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
% int usb_find_busses ( void ); 
fcns.thunkname{fcnNum}='int32voidThunk';fcns.name{fcnNum}='usb_find_busses'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% int usb_find_devices ( void ); 
fcns.thunkname{fcnNum}='int32voidThunk';fcns.name{fcnNum}='usb_find_devices'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% struct usb_device * usb_device ( usb_dev_handle * dev ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrThunk';fcns.name{fcnNum}='usb_device'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='usb_devicePtr'; fcns.RHS{fcnNum}={'usb_dev_handlePtr'};fcnNum=fcnNum+1;
% struct usb_bus * usb_get_busses ( void ); 
fcns.thunkname{fcnNum}='voidPtrvoidThunk';fcns.name{fcnNum}='usb_get_busses'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='usb_busPtr'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% int usb_install_service_np ( void ); 
fcns.thunkname{fcnNum}='int32voidThunk';fcns.name{fcnNum}='usb_install_service_np'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% void __stdcall usb_install_service_np_rundll ( HWND wnd , HINSTANCE instance , LPSTR cmd_line , int cmd_show ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='usb_install_service_np_rundll'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'HWND__Ptr', 'HINSTANCE__Ptr', 'int8Ptr', 'int32'};fcnNum=fcnNum+1;
% int usb_uninstall_service_np ( void ); 
fcns.thunkname{fcnNum}='int32voidThunk';fcns.name{fcnNum}='usb_uninstall_service_np'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% void __stdcall usb_uninstall_service_np_rundll ( HWND wnd , HINSTANCE instance , LPSTR cmd_line , int cmd_show ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='usb_uninstall_service_np_rundll'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'HWND__Ptr', 'HINSTANCE__Ptr', 'int8Ptr', 'int32'};fcnNum=fcnNum+1;
% int usb_install_driver_np ( const char * inf_file ); 
fcns.thunkname{fcnNum}='int32cstringThunk';fcns.name{fcnNum}='usb_install_driver_np'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'cstring'};fcnNum=fcnNum+1;
% void __stdcall usb_install_driver_np_rundll ( HWND wnd , HINSTANCE instance , LPSTR cmd_line , int cmd_show ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='usb_install_driver_np_rundll'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'HWND__Ptr', 'HINSTANCE__Ptr', 'int8Ptr', 'int32'};fcnNum=fcnNum+1;
% int usb_touch_inf_file_np ( const char * inf_file ); 
fcns.thunkname{fcnNum}='int32cstringThunk';fcns.name{fcnNum}='usb_touch_inf_file_np'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'cstring'};fcnNum=fcnNum+1;
% void __stdcall usb_touch_inf_file_np_rundll ( HWND wnd , HINSTANCE instance , LPSTR cmd_line , int cmd_show ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='usb_touch_inf_file_np_rundll'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'HWND__Ptr', 'HINSTANCE__Ptr', 'int8Ptr', 'int32'};fcnNum=fcnNum+1;
% int usb_install_needs_restart_np ( void ); 
fcns.thunkname{fcnNum}='int32voidThunk';fcns.name{fcnNum}='usb_install_needs_restart_np'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% int usb_install_npW ( HWND hwnd , HINSTANCE instance , LPCWSTR cmd_line , int starg_arg ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='usb_install_npW'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'HWND__Ptr', 'HINSTANCE__Ptr', 'uint16Ptr', 'int32'};fcnNum=fcnNum+1;
% int usb_install_npA ( HWND hwnd , HINSTANCE instance , LPCSTR cmd_line , int starg_arg ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='usb_install_npA'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'HWND__Ptr', 'HINSTANCE__Ptr', 'int8Ptr', 'int32'};fcnNum=fcnNum+1;
% void __stdcall usb_install_np_rundll ( HWND wnd , HINSTANCE instance , LPSTR cmd_line , int cmd_show ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='usb_install_np_rundll'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'HWND__Ptr', 'HINSTANCE__Ptr', 'int8Ptr', 'int32'};fcnNum=fcnNum+1;
% const struct usb_version * usb_get_version ( void ); 
fcns.thunkname{fcnNum}='voidPtrvoidThunk';fcns.name{fcnNum}='usb_get_version'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='voidPtr'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% int usb_isochronous_setup_async ( usb_dev_handle * dev , void ** context , unsigned char ep , int pktsize ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint8int32Thunk';fcns.name{fcnNum}='usb_isochronous_setup_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'voidPtrPtr', 'uint8', 'int32'};fcnNum=fcnNum+1;
% int usb_bulk_setup_async ( usb_dev_handle * dev , void ** context , unsigned char ep ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint8Thunk';fcns.name{fcnNum}='usb_bulk_setup_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'voidPtrPtr', 'uint8'};fcnNum=fcnNum+1;
% int usb_interrupt_setup_async ( usb_dev_handle * dev , void ** context , unsigned char ep ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint8Thunk';fcns.name{fcnNum}='usb_interrupt_setup_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'usb_dev_handlePtr', 'voidPtrPtr', 'uint8'};fcnNum=fcnNum+1;
% int usb_submit_async ( void * context , char * bytes , int size ); 
fcns.thunkname{fcnNum}='int32voidPtrcstringint32Thunk';fcns.name{fcnNum}='usb_submit_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'cstring', 'int32'};fcnNum=fcnNum+1;
% int usb_reap_async ( void * context , int timeout ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='usb_reap_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'int32'};fcnNum=fcnNum+1;
% int usb_reap_async_nocancel ( void * context , int timeout ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='usb_reap_async_nocancel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'int32'};fcnNum=fcnNum+1;
% int usb_cancel_async ( void * context ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='usb_cancel_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% int usb_free_async ( void ** context ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='usb_free_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtrPtr'};fcnNum=fcnNum+1;
structs.HWND__.members=struct('unused', 'int32');
structs.HINSTANCE__.members=struct('unused', 'int32');
structs.usb_descriptor_header.packing=1;
structs.usb_descriptor_header.members=struct('bLength', 'uint8', 'bDescriptorType', 'uint8');
structs.usb_string_descriptor.packing=1;
structs.usb_string_descriptor.members=struct('bLength', 'uint8', 'bDescriptorType', 'uint8', 'wData', 'uint16#1');
structs.usb_hid_descriptor.packing=1;
structs.usb_hid_descriptor.members=struct('bLength', 'uint8', 'bDescriptorType', 'uint8', 'bcdHID', 'uint16', 'bCountryCode', 'uint8', 'bNumDescriptors', 'uint8');
structs.usb_endpoint_descriptor.packing=1;
structs.usb_endpoint_descriptor.members=struct('bLength', 'uint8', 'bDescriptorType', 'uint8', 'bEndpointAddress', 'uint8', 'bmAttributes', 'uint8', 'wMaxPacketSize', 'uint16', 'bInterval', 'uint8', 'bRefresh', 'uint8', 'bSynchAddress', 'uint8', 'extra', 'uint8Ptr', 'extralen', 'int32');
structs.usb_interface_descriptor.packing=1;
structs.usb_interface_descriptor.members=struct('bLength', 'uint8', 'bDescriptorType', 'uint8', 'bInterfaceNumber', 'uint8', 'bAlternateSetting', 'uint8', 'bNumEndpoints', 'uint8', 'bInterfaceClass', 'uint8', 'bInterfaceSubClass', 'uint8', 'bInterfaceProtocol', 'uint8', 'iInterface', 'uint8', 'endpoint', 'usb_endpoint_descriptorPtr', 'extra', 'uint8Ptr', 'extralen', 'int32');
structs.usb_interface.packing=1;
structs.usb_interface.members=struct('altsetting', 'usb_interface_descriptorPtr', 'num_altsetting', 'int32');
structs.usb_config_descriptor.packing=1;
structs.usb_config_descriptor.members=struct('bLength', 'uint8', 'bDescriptorType', 'uint8', 'wTotalLength', 'uint16', 'bNumInterfaces', 'uint8', 'bConfigurationValue', 'uint8', 'iConfiguration', 'uint8', 'bmAttributes', 'uint8', 'MaxPower', 'uint8', 'interface', 'usb_interfacePtr', 'extra', 'uint8Ptr', 'extralen', 'int32');
structs.usb_device_descriptor.packing=1;
structs.usb_device_descriptor.members=struct('bLength', 'uint8', 'bDescriptorType', 'uint8', 'bcdUSB', 'uint16', 'bDeviceClass', 'uint8', 'bDeviceSubClass', 'uint8', 'bDeviceProtocol', 'uint8', 'bMaxPacketSize0', 'uint8', 'idVendor', 'uint16', 'idProduct', 'uint16', 'bcdDevice', 'uint16', 'iManufacturer', 'uint8', 'iProduct', 'uint8', 'iSerialNumber', 'uint8', 'bNumConfigurations', 'uint8');
structs.usb_ctrl_setup.packing=1;
structs.usb_ctrl_setup.members=struct('bRequestType', 'uint8', 'bRequest', 'uint8', 'wValue', 'uint16', 'wIndex', 'uint16', 'wLength', 'uint16');
structs.usb_device.packing=1;
structs.usb_device.members=struct('next', 'usb_devicePtr', 'prev', 'usb_devicePtrPtr', 'filename', 'int8#512', 'bus', 'usb_busPtr', 'descriptor', 'usb_device_descriptor', 'config', 'usb_config_descriptorPtr', 'dev', 'voidPtr', 'devnum', 'uint8', 'num_children', 'uint8', 'children', 'usb_devicePtrPtr');
structs.usb_bus.packing=1;
structs.usb_bus.members=struct('next', 'usb_busPtr', 'prev', 'usb_busPtrPtr', 'dirname', 'int8#512', 'devices', 'usb_devicePtr', 'location', 'ulong', 'root_dev', 'usb_devicePtr');
structs.usb_dev_handle.packing=1;
structs.usb_dev_handle.members=struct('');
methodinfo=fcns;